Index: src/main/java/model/game/Game.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package model.game;\n\nimport controller.CardController;\nimport controller.PlayerController;\nimport javafx.stage.Stage;\nimport model.Account.Player;\nimport model.Account.User;\nimport model.Enum.GameRegexes;\nimport model.role.Leader;\n\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class Game implements Runnable {\n\n    private final Player[] players;\n    private PlayerController[] playerControllers;\n    private CommunicationHandler[] communicationHandlers;\n    private short passedTurnCounter;\n\n    private ServerSocket server;\n    private ExecutorService pool;\n\n    private int turn;\n    private boolean running = false;\n    private StringBuilder log;\n    private int numTurn = 0;\n\n    private boolean isPlayerListening;\n\n    private static Game currentGame = null;\n\n    public Game(User user1, User user2) {\n        try {\n            server = new ServerSocket(8080);\n        } catch (IOException e) {\n            e.printStackTrace();\n            // TODO handle\n        }\n        communicationHandlers = new CommunicationHandler[2];\n        players = new Player[2];\n        log = new StringBuilder();\n        createPlayers(user1, user2);\n        passedTurnCounter = 0;\n    }\n\n    @Override\n    public void run() {\n\n        try {\n            pool = Executors.newCachedThreadPool();\n\n            // writing trash\n            Socket p1 = server.accept();\n\n            // player 1\n            Thread t = new Thread(getPlayer1());\n            t.start();\n            CommunicationHandler tunnel1 = new CommunicationHandler(p1, getPlayer1());\n            communicationHandlers[0] = tunnel1;\n            pool.execute(tunnel1);\n\n            // player 2\n            Socket p2 = server.accept();\n            Thread t2 = new Thread(getPlayer2());\n            t2.start();\n            CommunicationHandler tunnel2 = new CommunicationHandler(p2, getPlayer2());\n            communicationHandlers[1] = tunnel2;\n            pool.execute(tunnel2);\n\n            isPlayerListening = true;\n\n            // choose card\n//            chooseCard();\n            \n            while (gameStillOn()) {\n                getReadyToCommuincateWithPlayer();\n                tunnel1.startCommunication();\n\n                getReadyToCommuincateWithPlayer();\n                tunnel1.startTurn();\n\n                getReadyToCommuincateWithPlayer();\n                tunnel2.startCommunication();\n\n                getReadyToCommuincateWithPlayer();\n                tunnel2.startTurn();\n            }\n\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private void waitUntilPlayerIsAvailable() {\n        while (!isPlayerListening) {\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                break;\n            }\n        }\n    }\n\n\n    class CommunicationHandler implements Runnable {\n        private Socket socket;\n        private DataInputStream in;\n        private DataOutputStream out;\n        private Player player;\n\n        public CommunicationHandler(Socket socket, Player player) {\n            this.socket = socket;\n            this.player = player;\n            try {\n                out = new DataOutputStream(socket.getOutputStream());\n                in = new DataInputStream(socket.getInputStream());\n            } catch (IOException e) {\n                e.printStackTrace();\n                // TODO handle\n            }\n        }\n\n        @Override\n        public void run() {\n\n            try {\n                String inMessage;\n                while ((inMessage = in.readUTF()) != null) {\n                    // for debug purpose\n                    System.out.println(\"[SERVER] message from player \" + player.getUser().getName() + \" :  \\\"\" + inMessage + \"\\\"\");\n                    handleCommand(inMessage, getPlayer(), getOpp().getPlayer());\n//\n//                    if (response != null) {\n//                        System.out.println(\"[SERVER] response to player: \\\"\" + response + \"\\\"\");\n//                        sendMessage(response);\n//                    }\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n\n        }\n\n        public Player getPlayer() {\n            return player;\n        }\n\n        private CommunicationHandler getOpp() {\n            for (CommunicationHandler c : communicationHandlers) {\n                if (c.equals(this)) continue;\n                else return c;\n            }\n\n            throw new IllegalStateException();\n        }\n\n        public void startCommunication() throws IOException {\n            sendMessage(\"start communication\");\n        }\n\n        public void sendMessage(String message) throws IOException {\n            out.writeUTF(message);\n        }\n\n        public void shutdown() {\n\n            try {\n                in.close();\n                out.close();\n                if (!socket.isClosed()) {\n                    socket.close();\n                }\n            } catch (IOException e) {\n                // TODO handle exception (perhaps ignore)\n            }\n        }\n\n        public void startTurn() throws IOException {\n            sendMessage(GameRegexes.START_TURN.toString());\n        }\n    }\n\n    private void shutdown() {\n        try {\n            running = false;\n\n            // TODO\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void getReadyToCommuincateWithPlayer() {\n        waitUntilPlayerIsAvailable();\n        isPlayerListening = false;\n    }\n\n    // commands\n//    private final static String openCommunicationCommand = \"open communication\",\n//        startTurnCommand = \"start turn \", // num turn will place at the end of this command\n//        chooseCardCommand = \"choose card\";\n\n    // regex\n    private final static String playerCommunicationAcceptedRegex = \"^communication accepted$\",\n            endTurnRegex = \"^end turn$\";\n\n\n    private static final String putCardRegex = \"^put card (\\\\S+) (\\\\S+)$\";\n\n\n    private void handleCommand(String command, Player caller, Player opp) throws IOException {\n\n//        if(GameRegexes.A_USER_PUT_CARD.matches(command)){\n//            getTunel1().sendMessage(command);\n//            getTunel2().sendMessage(command);\n//        }\n\n//        else\n        if (command.matches(putCardRegex)) {\n            Matcher matcher = getMatcher(putCardRegex, command);\n            matcher.find();\n            putCard(matcher, caller, opp);\n        } else if (command.matches(playerCommunicationAcceptedRegex)) {\n            System.out.println(\"[SUCC] communication has established\");\n            isPlayerListening = true;\n        } else if (GameRegexes.PLAY_LEADER.matches(command)) {\n            broadcastLeader(command);\n        } else if (command.matches(endTurnRegex)) {\n            System.out.println(\"[SERVER] the turn has ended\");\n            isPlayerListening = true;\n            passedTurnCounter = 0;\n        } else if (command.matches(\".+ passed\")) {\n            System.out.println(\"[SERVER] the turn has passed\");\n            if (++passedTurnCounter >= 2) {\n                checkForWinnerOfADiamond();\n            }\n            isPlayerListening = true;\n        } else if (GameRegexes.A_USER_PUT_CARD.matches(command)) {\n            puttingCardBroadCast(command);\n\n        } else if (command.matches(\"\\\\d\")) {\n            testMethod(command, caller, opp);\n        } else if (command.matches(\".+ has ready hand\")) {\n            getTunel1().sendMessage(command);\n            getTunel2().sendMessage(command);\n        } else if (GameRegexes.VETO_COMPLETED.matches(command)) {\n            getTunel1().sendMessage(command);\n            getTunel2().sendMessage(command);\n        } else if (GameRegexes.JSON_OF_ROWS.matches(command)) {\n            getTunel1().sendMessage(command);\n            getTunel2().sendMessage(command);\n        }\n\n    }\n\n    private void broadcastLeader(String command) throws IOException {\n        getTunel1().sendMessage(command);\n        getTunel2().sendMessage(command);\n    }\n\n    private void puttingCardBroadCast(String command) throws IOException {\n        getTunel1().sendMessage(command);\n        getTunel2().sendMessage(command);\n    }\n\n    private void checkForWinnerOfADiamond() {\n        // TODO: compare players points\n        // TODO: if(++ diamond == 2) WIN and LOOSE handling\n    }\n\n    private void testMethod(String command, Player caller, Player opp) throws IOException {\n        getTunel1().sendMessage(command);\n        getTunel2().sendMessage(command);\n    }\n\n    private boolean putCard(Matcher matcher, Player caller, Player opp) {\n        String cardName = matcher.group(1);\n        String pos = matcher.group(2);\n\n//        Card card;\n//        try {\n//            card = CardController.createCardWithName(cardName);\n//        } catch (RuntimeException e) {\n//            return false;\n//        }\n\n\n//        System.out.println(card);\n\n\n        // accepted\n//        String s = affectOnOpponent();\n\n        LOG(\"[\" + caller.getUser().getName() + \"]: put card \" + cardName + \" \" + pos);\n//        LOG(s);\n\n        broadcastLog();\n        cleanLog();\n\n        return true;\n    }\n\n    private void LOG(CharSequence sequence) {\n        log.append(sequence).append('\\n');\n    }\n\n    private void cleanLog() {\n        log = new StringBuilder();\n    }\n\n    private void broadcastLog() {\n        CommunicationHandler t1 = getTunel1(),\n                t2 = getTunel2();\n\n        String[] arr = log.toString().split(\"\\n\");\n\n        try {\n            for (String l : arr) {\n                t1.sendMessage(l);\n                t2.sendMessage(l);\n            }\n        } catch (Exception e) {\n            throw new RuntimeException();\n        }\n    }\n\n    private void chooseCard() {\n        CommunicationHandler t1 = getTunel1(),\n                t2 = getTunel2();\n\n        try {\n            getReadyToCommuincateWithPlayer();\n            t1.startCommunication();\n\n            getReadyToCommuincateWithPlayer();\n            t1.sendMessage(GameRegexes.CHOOSE_CARD.toString());\n\n            getReadyToCommuincateWithPlayer();\n            t2.startCommunication();\n\n            getReadyToCommuincateWithPlayer();\n            t2.sendMessage(GameRegexes.CHOOSE_CARD.toString());\n\n\n        } catch (Exception e) {\n\n        }\n\n    }\n\n    private boolean gameStillOn() throws Exception {\n        // TODO define the rule for finishing the game\n        return true;\n    }\n\n    private void goNextTurn() throws Exception {\n        numTurn++;\n\n//        addToLog(\"start turn \" + numTurn);\n\n        // TODO\n    }\n\n    public void createPlayers(User user1, User user2) {\n        players[0] = new Player(user1, new Stage());\n        players[1] = new Player(user2, new Stage());\n    }\n\n    public Player getPlayer1() {\n        return players[0];\n    }\n\n    public Player getPlayer2() {\n        return players[1];\n    }\n\n    public PlayerController getController1() {\n        return playerControllers[0];\n    }\n\n    public PlayerController getController2() {\n        return playerControllers[1];\n    }\n\n    public static Game getCurrentGame() {\n        return currentGame;\n    }\n\n    public static void setCurrentGame(Game game) {\n        currentGame = game;\n    }\n\n    private CommunicationHandler getTunel1() {\n        return communicationHandlers[0];\n    }\n\n\n    private CommunicationHandler getTunel2() {\n        return communicationHandlers[1];\n    }\n\n    private static Matcher getMatcher(String regex, String command) {\n        return Pattern.compile(regex).matcher(command);\n    }\n\n    public static void main(String[] args) {\n        try {\n            CardController.load_data();\n        } catch (Exception e) {\n        }\n        User u1 = new User(\"ali\", \"a\", \"a\", \"a\");\n        User u2 = new User(\"erfan\", \"b\", \"b\", \"b\");\n        u1.setDeck(u1.getRandomDeck());\n        u2.setDeck(u1.getRandomDeck());\n        Game game = new Game(u1, u2);\n        game.run();\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/model/game/Game.java b/src/main/java/model/game/Game.java
--- a/src/main/java/model/game/Game.java	
+++ b/src/main/java/model/game/Game.java	
@@ -414,16 +414,16 @@
         return Pattern.compile(regex).matcher(command);
     }
 
-    public static void main(String[] args) {
-        try {
-            CardController.load_data();
-        } catch (Exception e) {
-        }
-        User u1 = new User("ali", "a", "a", "a");
-        User u2 = new User("erfan", "b", "b", "b");
-        u1.setDeck(u1.getRandomDeck());
-        u2.setDeck(u1.getRandomDeck());
-        Game game = new Game(u1, u2);
-        game.run();
-    }
+//    public static void main(String[] args) {
+//        try {
+//            CardController.load_data();
+//        } catch (Exception e) {
+//        }
+//        User u1 = new User("ali", "a", "a", "a");
+//        User u2 = new User("erfan", "b", "b", "b");
+//        u1.setDeck(u1.getRandomDeck());
+//        u2.setDeck(u1.getRandomDeck());
+//        Game game = new Game(u1, u2);
+//        game.run();
+//    }
 }
